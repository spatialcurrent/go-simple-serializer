// =================================================================
//
// Copyright (C) 2019 Spatial Current, Inc. - All Rights Reserved
// Released as open source under the MIT License.  See LICENSE file.
//
// =================================================================

package rapid

import (
  "bufio"
  "fmt"
  "io"
  "strconv"
)

type Decoder struct {
  dictionary *Dictionary
  reader *bufio.Reader
  headerFeature byte
  headerPath byte
  headerKey byte
  typeString byte
  typeInt byte
  typeFloat byte
  separator byte
  trailer byte
}

func NewDecoder(r io.Reader) *Decoder {
  return &Decoder{
    dictionary: NewDictionary(),
    reader: bufio.NewReader(r),
    headerFeature: 'F',
    headerPath: 'P',
    headerKey: 'K',
    typeString: 'S',
    typeInt: 'I',
    typeFloat: 'F',
    separator: ' ',
    trailer: '\n',
  }
}

func (d *Decoder) readSeparator() error {
  b, err := d.reader.ReadByte()
  if err != nil {
    return fmt.Errorf("error reading byte: %w", err)
  }
  if b != d.separator {
    return fmt.Errorf("expecting separator after header, but found %q", string([]byte{b}))
  }
  return nil
}

func (d *Decoder) readPathHeader() error {
  b, err := d.reader.ReadByte()
  if err != nil {
    return fmt.Errorf("error reading byte: %w", err)
  }
  if b != d.headerPath {
    return fmt.Errorf("expecting path header %q, but found %q", d.headerPath, string([]byte{b}))
  }
  return nil
}

func (d *Decoder) readInt() (int, error) {
  b, err := d.readUntilSeparator()
  if err != nil {
    return 0, fmt.Errorf("error reading until separator: %w", err)
  }
  v, err := strconv.Atoi(string(b))
  if err != nil {
    return 0, fmt.Errorf("error parsing integer from %q: %w", string(b), err)
  }
  return v, nil
}

func (d *Decoder) readUntilSeparator() ([]byte, error) {
  b, err := d.reader.ReadBytes(d.separator)
  if err != nil {
    return make([]byte, 0), fmt.Errorf("error reading bytes: %w", err)
  }
  return b[0:len(b)-1], nil
}

func (d *Decoder) readUntilTrailer() ([]byte, error) {
  b, err := d.reader.ReadBytes(d.trailer)
  if err != nil {
    return make([]byte, 0), fmt.Errorf("error reading bytes: %w", err)
  }
  return b[0:len(b)-1], nil
}

func (d *Decoder) readKey() error {
  if err := d.readSeparator(); err != nil {
    return fmt.Errorf("error reading byte: %w", err)
  }
  t, err := d.reader.ReadByte()
  if err != nil {
    return fmt.Errorf("error reading byte: %w", err)
  }
  if t == d.typeString {
    v, err := d.readUntilTrailer()
    if err != nil {
      return fmt.Errorf("error reading byte: %w", err)
    }
    _ = d.dictionary.AddKey(string(v[0:len(v) -1]))
  }
  return nil
}

func (d *Decoder) readFeature() ([][]int, error) {

  if err := d.readSeparator(); err != nil {
    return make([][]int, 0), fmt.Errorf("error reading byte: %w", err)
  }

  numberOfPaths, err := d.readInt()
  if err != nil {
    return make([][]int, 0), fmt.Errorf("error reading number of paths: %w", err)
  }

  if numberOfPaths == 0 {
    _, err := d.readUntilTrailer()
    if err != nil {
      return make([][]int, 0), fmt.Errorf("error reading until separator: %w", err)
    }
    return make([][]int, 0), nil
  }

  paths := make([][]int, 0)
  for i := 0; i < numberOfPaths; i++ {
    if i < numberOfPaths - 1 {
      if err := d.readPathHeader(); err != nil {
        return make([][]int, 0), fmt.Errorf("error reading path header: %w", err)
      }
      _, err := d.readUntilSeparator()
      if err != nil {
        return make([][]int, 0), fmt.Errorf("error reading until separator: %w", err)
      }
      numberOfIndicies, err := d.readInt()
      if err != nil {
        return make([][]int, 0), fmt.Errorf("error reading number of paths: %w", err)
      }
      path := make([]int, 0)
      for j := 0; j < numberOfIndicies; j++ {
        index, err := d.readInt()
        if err != nil {
          return make([][]int, 0), fmt.Errorf("error reading number of paths: %w", err)
        }
        path = append(path, index)
      }
      paths = append(paths, path)
    } else {
      //paths = append(paths, path)
    }
  }

  return paths, nil
}

func (d *Decoder) Decode(v interface{}) error {

  for {
    h, err := d.reader.ReadByte()
    if err != nil {
      return fmt.Errorf("error reading byte: %w", err)
    }
    if h == d.headerKey {
      if err := d.readKey(); err != nil {
        return fmt.Errorf("error reading byte: %w", err)
      }
      continue
    }
    if h == d.headerFeature {
      paths, err := d.readFeature()
      if err != nil {
        return fmt.Errorf("error reading feature: %w", err)
      }
      fmt.Println("paths:", paths)
    }
  }

}
